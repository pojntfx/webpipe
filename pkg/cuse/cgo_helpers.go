// WARNING: This file has automatically been generated on Thu, 19 May 2022 22:32:28 CEST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package cuse

/*
#cgo pkg-config: fuse3
#include <cuse_lowlevel.h>
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

func (x InterruptFunc) PassRef() (ref *C.fuse_interrupt_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if interruptFuncA8CB1480Func == nil {
		interruptFuncA8CB1480Func = x
	}
	return (*C.fuse_interrupt_func_t)(C.fuse_interrupt_func_t_a8cb1480), nil
}

func (x InterruptFunc) PassValue() (ref C.fuse_interrupt_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if interruptFuncA8CB1480Func == nil {
		interruptFuncA8CB1480Func = x
	}
	return (C.fuse_interrupt_func_t)(C.fuse_interrupt_func_t_a8cb1480), nil
}

func NewInterruptFuncRef(ref unsafe.Pointer) *InterruptFunc {
	return (*InterruptFunc)(ref)
}

//export interruptFuncA8CB1480
func interruptFuncA8CB1480(creq C.fuse_req_t, cdata unsafe.Pointer) {
	if interruptFuncA8CB1480Func != nil {
		reqa8cb1480 := *(*Req)(unsafe.Pointer(&creq))
		dataa8cb1480 := (unsafe.Pointer)(unsafe.Pointer(cdata))
		interruptFuncA8CB1480Func(reqa8cb1480, dataa8cb1480)
		return
	}
	panic("callback func has not been set (race?)")
}

var interruptFuncA8CB1480Func InterruptFunc

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// packSArgs reads sliced Go data structure out from plain C format.
func packSArgs(v []Args, ptr0 *C.struct_fuse_args) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructFuseArgsValue]C.struct_fuse_args)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewArgsRef(unsafe.Pointer(&ptr1))
	}
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

func (x OptProc) PassRef() (ref *C.fuse_opt_proc_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if optProc63352F8EFunc == nil {
		optProc63352F8EFunc = x
	}
	return (*C.fuse_opt_proc_t)(C.fuse_opt_proc_t_63352f8e), nil
}

func (x OptProc) PassValue() (ref C.fuse_opt_proc_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if optProc63352F8EFunc == nil {
		optProc63352F8EFunc = x
	}
	return (C.fuse_opt_proc_t)(C.fuse_opt_proc_t_63352f8e), nil
}

func NewOptProcRef(ref unsafe.Pointer) *OptProc {
	return (*OptProc)(ref)
}

//export optProc63352F8E
func optProc63352F8E(cdata unsafe.Pointer, carg *C.char, ckey C.int, coutargs *C.struct_fuse_args) C.int {
	if optProc63352F8EFunc != nil {
		data63352f8e := (unsafe.Pointer)(unsafe.Pointer(cdata))
		arg63352f8e := packPCharString(carg)
		key63352f8e := (int32)(ckey)
		var outargs63352f8e []Args
		packSArgs(outargs63352f8e, coutargs)
		ret63352f8e := optProc63352F8EFunc(data63352f8e, arg63352f8e, key63352f8e, outargs63352f8e)
		ret, _ := (C.int)(ret63352f8e), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var optProc63352F8EFunc OptProc

func (x LogFunc) PassRef() (ref *C.fuse_log_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if logFuncD65C7516Func == nil {
		logFuncD65C7516Func = x
	}
	return (*C.fuse_log_func_t)(C.fuse_log_func_t_d65c7516), nil
}

func (x LogFunc) PassValue() (ref C.fuse_log_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if logFuncD65C7516Func == nil {
		logFuncD65C7516Func = x
	}
	return (C.fuse_log_func_t)(C.fuse_log_func_t_d65c7516), nil
}

func NewLogFuncRef(ref unsafe.Pointer) *LogFunc {
	return (*LogFunc)(ref)
}

//export logFuncD65C7516
func logFuncD65C7516(clevel C.enum_fuse_log_level, cfmt *C.char, cap C.va_list) {
	if logFuncD65C7516Func != nil {
		leveld65c7516 := (LogLevel)(clevel)
		fmtd65c7516 := packPCharString(cfmt)
		apd65c7516 := (unsafe.Pointer)(unsafe.Pointer(cap))
		logFuncD65C7516Func(leveld65c7516, fmtd65c7516, apd65c7516)
		return
	}
	panic("callback func has not been set (race?)")
}

var logFuncD65C7516Func LogFunc

// allocStructCuseInfoMemory allocates memory for type C.struct_cuse_info in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructCuseInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructCuseInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructCuseInfoValue = unsafe.Sizeof([1]C.struct_cuse_info{})

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackSString transforms a sliced Go data structure into plain C format.
func unpackSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Info) Ref() *C.struct_cuse_info {
	if x == nil {
		return nil
	}
	return x.ref30ec17cc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Info) Free() {
	if x != nil && x.allocs30ec17cc != nil {
		x.allocs30ec17cc.(*cgoAllocMap).Free()
		x.ref30ec17cc = nil
	}
}

// NewInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewInfoRef(ref unsafe.Pointer) *Info {
	if ref == nil {
		return nil
	}
	obj := new(Info)
	obj.ref30ec17cc = (*C.struct_cuse_info)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Info) PassRef() (*C.struct_cuse_info, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref30ec17cc != nil {
		return x.ref30ec17cc, nil
	}
	mem30ec17cc := allocStructCuseInfoMemory(1)
	ref30ec17cc := (*C.struct_cuse_info)(mem30ec17cc)
	allocs30ec17cc := new(cgoAllocMap)
	allocs30ec17cc.Add(mem30ec17cc)

	var cdev_major_allocs *cgoAllocMap
	ref30ec17cc.dev_major, cdev_major_allocs = (C.uint)(x.DevMajor), cgoAllocsUnknown
	allocs30ec17cc.Borrow(cdev_major_allocs)

	var cdev_minor_allocs *cgoAllocMap
	ref30ec17cc.dev_minor, cdev_minor_allocs = (C.uint)(x.DevMinor), cgoAllocsUnknown
	allocs30ec17cc.Borrow(cdev_minor_allocs)

	var cdev_info_argc_allocs *cgoAllocMap
	ref30ec17cc.dev_info_argc, cdev_info_argc_allocs = (C.uint)(x.DevInfoArgc), cgoAllocsUnknown
	allocs30ec17cc.Borrow(cdev_info_argc_allocs)

	var cdev_info_argv_allocs *cgoAllocMap
	ref30ec17cc.dev_info_argv, cdev_info_argv_allocs = unpackSString(x.DevInfoArgv)
	allocs30ec17cc.Borrow(cdev_info_argv_allocs)

	var cflags_allocs *cgoAllocMap
	ref30ec17cc.flags, cflags_allocs = (C.uint)(x.Flags), cgoAllocsUnknown
	allocs30ec17cc.Borrow(cflags_allocs)

	x.ref30ec17cc = ref30ec17cc
	x.allocs30ec17cc = allocs30ec17cc
	return ref30ec17cc, allocs30ec17cc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Info) PassValue() (C.struct_cuse_info, *cgoAllocMap) {
	if x.ref30ec17cc != nil {
		return *x.ref30ec17cc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Info) Deref() {
	if x.ref30ec17cc == nil {
		return
	}
	x.DevMajor = (uint32)(x.ref30ec17cc.dev_major)
	x.DevMinor = (uint32)(x.ref30ec17cc.dev_minor)
	x.DevInfoArgc = (uint32)(x.ref30ec17cc.dev_info_argc)
	packSString(x.DevInfoArgv, x.ref30ec17cc.dev_info_argv)
	x.Flags = (uint32)(x.ref30ec17cc.flags)
}

// allocStructCuseLowlevelOpsMemory allocates memory for type C.struct_cuse_lowlevel_ops in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructCuseLowlevelOpsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructCuseLowlevelOpsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructCuseLowlevelOpsValue = unsafe.Sizeof([1]C.struct_cuse_lowlevel_ops{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *LowlevelOps) Ref() *C.struct_cuse_lowlevel_ops {
	if x == nil {
		return nil
	}
	return x.refa7a7b71f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *LowlevelOps) Free() {
	if x != nil && x.allocsa7a7b71f != nil {
		x.allocsa7a7b71f.(*cgoAllocMap).Free()
		x.refa7a7b71f = nil
	}
}

// NewLowlevelOpsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewLowlevelOpsRef(ref unsafe.Pointer) *LowlevelOps {
	if ref == nil {
		return nil
	}
	obj := new(LowlevelOps)
	obj.refa7a7b71f = (*C.struct_cuse_lowlevel_ops)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *LowlevelOps) PassRef() (*C.struct_cuse_lowlevel_ops, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa7a7b71f != nil {
		return x.refa7a7b71f, nil
	}
	mema7a7b71f := allocStructCuseLowlevelOpsMemory(1)
	refa7a7b71f := (*C.struct_cuse_lowlevel_ops)(mema7a7b71f)
	allocsa7a7b71f := new(cgoAllocMap)
	allocsa7a7b71f.Add(mema7a7b71f)

	var cinit_allocs *cgoAllocMap
	refa7a7b71f.init, cinit_allocs = x.Init.PassRef()
	allocsa7a7b71f.Borrow(cinit_allocs)

	var cinit_done_allocs *cgoAllocMap
	refa7a7b71f.init_done, cinit_done_allocs = x.InitDone.PassRef()
	allocsa7a7b71f.Borrow(cinit_done_allocs)

	var cdestroy_allocs *cgoAllocMap
	refa7a7b71f.destroy, cdestroy_allocs = x.Destroy.PassRef()
	allocsa7a7b71f.Borrow(cdestroy_allocs)

	var copen_allocs *cgoAllocMap
	refa7a7b71f.open, copen_allocs = x.Open.PassRef()
	allocsa7a7b71f.Borrow(copen_allocs)

	var cread_allocs *cgoAllocMap
	refa7a7b71f.read, cread_allocs = x.Read.PassRef()
	allocsa7a7b71f.Borrow(cread_allocs)

	var cwrite_allocs *cgoAllocMap
	refa7a7b71f.write, cwrite_allocs = x.Write.PassRef()
	allocsa7a7b71f.Borrow(cwrite_allocs)

	var cflush_allocs *cgoAllocMap
	refa7a7b71f.flush, cflush_allocs = x.Flush.PassRef()
	allocsa7a7b71f.Borrow(cflush_allocs)

	var crelease_allocs *cgoAllocMap
	refa7a7b71f.release, crelease_allocs = x.Release.PassRef()
	allocsa7a7b71f.Borrow(crelease_allocs)

	var cfsync_allocs *cgoAllocMap
	refa7a7b71f.fsync, cfsync_allocs = x.Fsync.PassRef()
	allocsa7a7b71f.Borrow(cfsync_allocs)

	var cioctl_allocs *cgoAllocMap
	refa7a7b71f.ioctl, cioctl_allocs = x.Ioctl.PassRef()
	allocsa7a7b71f.Borrow(cioctl_allocs)

	var cpoll_allocs *cgoAllocMap
	refa7a7b71f.poll, cpoll_allocs = x.Poll.PassRef()
	allocsa7a7b71f.Borrow(cpoll_allocs)

	x.refa7a7b71f = refa7a7b71f
	x.allocsa7a7b71f = allocsa7a7b71f
	return refa7a7b71f, allocsa7a7b71f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x LowlevelOps) PassValue() (C.struct_cuse_lowlevel_ops, *cgoAllocMap) {
	if x.refa7a7b71f != nil {
		return *x.refa7a7b71f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *LowlevelOps) Deref() {
	if x.refa7a7b71f == nil {
		return
	}
	x.Init = NewRef(unsafe.Pointer(x.refa7a7b71f.init))
	x.InitDone = NewRef(unsafe.Pointer(x.refa7a7b71f.init_done))
	x.Destroy = NewRef(unsafe.Pointer(x.refa7a7b71f.destroy))
	x.Open = NewRef(unsafe.Pointer(x.refa7a7b71f.open))
	x.Read = NewRef(unsafe.Pointer(x.refa7a7b71f.read))
	x.Write = NewRef(unsafe.Pointer(x.refa7a7b71f.write))
	x.Flush = NewRef(unsafe.Pointer(x.refa7a7b71f.flush))
	x.Release = NewRef(unsafe.Pointer(x.refa7a7b71f.release))
	x.Fsync = NewRef(unsafe.Pointer(x.refa7a7b71f.fsync))
	x.Ioctl = NewRef(unsafe.Pointer(x.refa7a7b71f.ioctl))
	x.Poll = NewRef(unsafe.Pointer(x.refa7a7b71f.poll))
}

// allocStructFuseArgsMemory allocates memory for type C.struct_fuse_args in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFuseArgsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFuseArgsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFuseArgsValue = unsafe.Sizeof([1]C.struct_fuse_args{})

// unpackSSByte transforms a sliced Go data structure into plain C format.
func unpackSSByte(x [][]byte) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.char)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// packSSByte reads sliced Go data structure out from plain C format.
func packSSByte(v [][]byte, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		hxfc4425b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfc4425b.Data = unsafe.Pointer(ptr1)
		hxfc4425b.Cap = 0x7fffffff
		// hxfc4425b.Len = ?
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Args) Ref() *C.struct_fuse_args {
	if x == nil {
		return nil
	}
	return x.refa7e94d76
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Args) Free() {
	if x != nil && x.allocsa7e94d76 != nil {
		x.allocsa7e94d76.(*cgoAllocMap).Free()
		x.refa7e94d76 = nil
	}
}

// NewArgsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewArgsRef(ref unsafe.Pointer) *Args {
	if ref == nil {
		return nil
	}
	obj := new(Args)
	obj.refa7e94d76 = (*C.struct_fuse_args)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Args) PassRef() (*C.struct_fuse_args, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa7e94d76 != nil {
		return x.refa7e94d76, nil
	}
	mema7e94d76 := allocStructFuseArgsMemory(1)
	refa7e94d76 := (*C.struct_fuse_args)(mema7e94d76)
	allocsa7e94d76 := new(cgoAllocMap)
	allocsa7e94d76.Add(mema7e94d76)

	var cargc_allocs *cgoAllocMap
	refa7e94d76.argc, cargc_allocs = (C.int)(x.Argc), cgoAllocsUnknown
	allocsa7e94d76.Borrow(cargc_allocs)

	var cargv_allocs *cgoAllocMap
	refa7e94d76.argv, cargv_allocs = unpackSSByte(x.Argv)
	allocsa7e94d76.Borrow(cargv_allocs)

	var callocated_allocs *cgoAllocMap
	refa7e94d76.allocated, callocated_allocs = (C.int)(x.Allocated), cgoAllocsUnknown
	allocsa7e94d76.Borrow(callocated_allocs)

	x.refa7e94d76 = refa7e94d76
	x.allocsa7e94d76 = allocsa7e94d76
	return refa7e94d76, allocsa7e94d76

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Args) PassValue() (C.struct_fuse_args, *cgoAllocMap) {
	if x.refa7e94d76 != nil {
		return *x.refa7e94d76, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Args) Deref() {
	if x.refa7e94d76 == nil {
		return
	}
	x.Argc = (int32)(x.refa7e94d76.argc)
	packSSByte(x.Argv, x.refa7e94d76.argv)
	x.Allocated = (int32)(x.refa7e94d76.allocated)
}

// allocStructFuseBufMemory allocates memory for type C.struct_fuse_buf in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFuseBufMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFuseBufValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFuseBufValue = unsafe.Sizeof([1]C.struct_fuse_buf{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Buf) Ref() *C.struct_fuse_buf {
	if x == nil {
		return nil
	}
	return x.refbb017fb9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Buf) Free() {
	if x != nil && x.allocsbb017fb9 != nil {
		x.allocsbb017fb9.(*cgoAllocMap).Free()
		x.refbb017fb9 = nil
	}
}

// NewBufRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufRef(ref unsafe.Pointer) *Buf {
	if ref == nil {
		return nil
	}
	obj := new(Buf)
	obj.refbb017fb9 = (*C.struct_fuse_buf)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Buf) PassRef() (*C.struct_fuse_buf, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbb017fb9 != nil {
		return x.refbb017fb9, nil
	}
	membb017fb9 := allocStructFuseBufMemory(1)
	refbb017fb9 := (*C.struct_fuse_buf)(membb017fb9)
	allocsbb017fb9 := new(cgoAllocMap)
	allocsbb017fb9.Add(membb017fb9)

	var csize_allocs *cgoAllocMap
	refbb017fb9.size, csize_allocs = (C.size_t)(x.Size), cgoAllocsUnknown
	allocsbb017fb9.Borrow(csize_allocs)

	var cflags_allocs *cgoAllocMap
	refbb017fb9.flags, cflags_allocs = (C.enum_fuse_buf_flags)(x.Flags), cgoAllocsUnknown
	allocsbb017fb9.Borrow(cflags_allocs)

	var cmem_allocs *cgoAllocMap
	refbb017fb9.mem, cmem_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Mem)), cgoAllocsUnknown
	allocsbb017fb9.Borrow(cmem_allocs)

	var cfd_allocs *cgoAllocMap
	refbb017fb9.fd, cfd_allocs = (C.int)(x.Fd), cgoAllocsUnknown
	allocsbb017fb9.Borrow(cfd_allocs)

	var cpos_allocs *cgoAllocMap
	refbb017fb9.pos, cpos_allocs = (C.off_t)(x.Pos), cgoAllocsUnknown
	allocsbb017fb9.Borrow(cpos_allocs)

	x.refbb017fb9 = refbb017fb9
	x.allocsbb017fb9 = allocsbb017fb9
	return refbb017fb9, allocsbb017fb9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Buf) PassValue() (C.struct_fuse_buf, *cgoAllocMap) {
	if x.refbb017fb9 != nil {
		return *x.refbb017fb9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Buf) Deref() {
	if x.refbb017fb9 == nil {
		return
	}
	x.Size = (uint32)(x.refbb017fb9.size)
	x.Flags = (BufFlags)(x.refbb017fb9.flags)
	x.Mem = (unsafe.Pointer)(unsafe.Pointer(x.refbb017fb9.mem))
	x.Fd = (int32)(x.refbb017fb9.fd)
	x.Pos = (int32)(x.refbb017fb9.pos)
}

// allocStructFuseBufvecMemory allocates memory for type C.struct_fuse_bufvec in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFuseBufvecMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFuseBufvecValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFuseBufvecValue = unsafe.Sizeof([1]C.struct_fuse_bufvec{})

// allocA1StructFuseBufMemory allocates memory for type [1]C.struct_fuse_buf in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA1StructFuseBufMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA1StructFuseBufValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA1StructFuseBufValue = unsafe.Sizeof([1][1]C.struct_fuse_buf{})

// unpackA1Buf transforms a sliced Go data structure into plain C format.
func unpackA1Buf(x [1]Buf) (unpacked [1]C.struct_fuse_buf, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA1StructFuseBufMemory(1)
	allocs.Add(mem0)
	v0 := (*[1]C.struct_fuse_buf)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[1]C.struct_fuse_buf)(mem0)
	return
}

// packA1Buf reads sliced Go data structure out from plain C format.
func packA1Buf(v *[1]Buf, ptr0 *[1]C.struct_fuse_buf) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewBufRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Bufvec) Ref() *C.struct_fuse_bufvec {
	if x == nil {
		return nil
	}
	return x.ref7623f27b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Bufvec) Free() {
	if x != nil && x.allocs7623f27b != nil {
		x.allocs7623f27b.(*cgoAllocMap).Free()
		x.ref7623f27b = nil
	}
}

// NewBufvecRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufvecRef(ref unsafe.Pointer) *Bufvec {
	if ref == nil {
		return nil
	}
	obj := new(Bufvec)
	obj.ref7623f27b = (*C.struct_fuse_bufvec)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Bufvec) PassRef() (*C.struct_fuse_bufvec, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7623f27b != nil {
		return x.ref7623f27b, nil
	}
	mem7623f27b := allocStructFuseBufvecMemory(1)
	ref7623f27b := (*C.struct_fuse_bufvec)(mem7623f27b)
	allocs7623f27b := new(cgoAllocMap)
	allocs7623f27b.Add(mem7623f27b)

	var ccount_allocs *cgoAllocMap
	ref7623f27b.count, ccount_allocs = (C.size_t)(x.Count), cgoAllocsUnknown
	allocs7623f27b.Borrow(ccount_allocs)

	var cidx_allocs *cgoAllocMap
	ref7623f27b.idx, cidx_allocs = (C.size_t)(x.Idx), cgoAllocsUnknown
	allocs7623f27b.Borrow(cidx_allocs)

	var coff_allocs *cgoAllocMap
	ref7623f27b.off, coff_allocs = (C.size_t)(x.Off), cgoAllocsUnknown
	allocs7623f27b.Borrow(coff_allocs)

	var cbuf_allocs *cgoAllocMap
	ref7623f27b.buf, cbuf_allocs = unpackA1Buf(x.Buf)
	allocs7623f27b.Borrow(cbuf_allocs)

	x.ref7623f27b = ref7623f27b
	x.allocs7623f27b = allocs7623f27b
	return ref7623f27b, allocs7623f27b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Bufvec) PassValue() (C.struct_fuse_bufvec, *cgoAllocMap) {
	if x.ref7623f27b != nil {
		return *x.ref7623f27b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Bufvec) Deref() {
	if x.ref7623f27b == nil {
		return
	}
	x.Count = (uint32)(x.ref7623f27b.count)
	x.Idx = (uint32)(x.ref7623f27b.idx)
	x.Off = (uint32)(x.ref7623f27b.off)
	packA1Buf(&x.Buf, (*[1]C.struct_fuse_buf)(unsafe.Pointer(&x.ref7623f27b.buf)))
}

// allocStructFuseCmdlineOptsMemory allocates memory for type C.struct_fuse_cmdline_opts in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFuseCmdlineOptsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFuseCmdlineOptsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFuseCmdlineOptsValue = unsafe.Sizeof([1]C.struct_fuse_cmdline_opts{})

// copyPCharBytes copies the data from Go slice as *C.char.
func copyPCharBytes(slice *sliceHeader) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfCharValue) * slice.Len,
		Cap:  int(sizeOfCharValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.char)(mem0), allocs
}

// allocCharMemory allocates memory for type C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCharValue = unsafe.Sizeof([1]C.char{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CmdlineOpts) Ref() *C.struct_fuse_cmdline_opts {
	if x == nil {
		return nil
	}
	return x.refd34a9b90
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CmdlineOpts) Free() {
	if x != nil && x.allocsd34a9b90 != nil {
		x.allocsd34a9b90.(*cgoAllocMap).Free()
		x.refd34a9b90 = nil
	}
}

// NewCmdlineOptsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCmdlineOptsRef(ref unsafe.Pointer) *CmdlineOpts {
	if ref == nil {
		return nil
	}
	obj := new(CmdlineOpts)
	obj.refd34a9b90 = (*C.struct_fuse_cmdline_opts)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CmdlineOpts) PassRef() (*C.struct_fuse_cmdline_opts, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd34a9b90 != nil {
		return x.refd34a9b90, nil
	}
	memd34a9b90 := allocStructFuseCmdlineOptsMemory(1)
	refd34a9b90 := (*C.struct_fuse_cmdline_opts)(memd34a9b90)
	allocsd34a9b90 := new(cgoAllocMap)
	allocsd34a9b90.Add(memd34a9b90)

	var csinglethread_allocs *cgoAllocMap
	refd34a9b90.singlethread, csinglethread_allocs = (C.int)(x.Singlethread), cgoAllocsUnknown
	allocsd34a9b90.Borrow(csinglethread_allocs)

	var cforeground_allocs *cgoAllocMap
	refd34a9b90.foreground, cforeground_allocs = (C.int)(x.Foreground), cgoAllocsUnknown
	allocsd34a9b90.Borrow(cforeground_allocs)

	var cdebug_allocs *cgoAllocMap
	refd34a9b90.debug, cdebug_allocs = (C.int)(x.Debug), cgoAllocsUnknown
	allocsd34a9b90.Borrow(cdebug_allocs)

	var cnodefault_subtype_allocs *cgoAllocMap
	refd34a9b90.nodefault_subtype, cnodefault_subtype_allocs = (C.int)(x.NodefaultSubtype), cgoAllocsUnknown
	allocsd34a9b90.Borrow(cnodefault_subtype_allocs)

	var cmountpoint_allocs *cgoAllocMap
	refd34a9b90.mountpoint, cmountpoint_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.Mountpoint)))
	allocsd34a9b90.Borrow(cmountpoint_allocs)

	var cshow_version_allocs *cgoAllocMap
	refd34a9b90.show_version, cshow_version_allocs = (C.int)(x.ShowVersion), cgoAllocsUnknown
	allocsd34a9b90.Borrow(cshow_version_allocs)

	var cshow_help_allocs *cgoAllocMap
	refd34a9b90.show_help, cshow_help_allocs = (C.int)(x.ShowHelp), cgoAllocsUnknown
	allocsd34a9b90.Borrow(cshow_help_allocs)

	var cclone_fd_allocs *cgoAllocMap
	refd34a9b90.clone_fd, cclone_fd_allocs = (C.int)(x.CloneFd), cgoAllocsUnknown
	allocsd34a9b90.Borrow(cclone_fd_allocs)

	var cmax_idle_threads_allocs *cgoAllocMap
	refd34a9b90.max_idle_threads, cmax_idle_threads_allocs = (C.uint)(x.MaxIdleThreads), cgoAllocsUnknown
	allocsd34a9b90.Borrow(cmax_idle_threads_allocs)

	x.refd34a9b90 = refd34a9b90
	x.allocsd34a9b90 = allocsd34a9b90
	return refd34a9b90, allocsd34a9b90

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CmdlineOpts) PassValue() (C.struct_fuse_cmdline_opts, *cgoAllocMap) {
	if x.refd34a9b90 != nil {
		return *x.refd34a9b90, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CmdlineOpts) Deref() {
	if x.refd34a9b90 == nil {
		return
	}
	x.Singlethread = (int32)(x.refd34a9b90.singlethread)
	x.Foreground = (int32)(x.refd34a9b90.foreground)
	x.Debug = (int32)(x.refd34a9b90.debug)
	x.NodefaultSubtype = (int32)(x.refd34a9b90.nodefault_subtype)
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.Mountpoint))
	hxf95e7c8.Data = unsafe.Pointer(x.refd34a9b90.mountpoint)
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	x.ShowVersion = (int32)(x.refd34a9b90.show_version)
	x.ShowHelp = (int32)(x.refd34a9b90.show_help)
	x.CloneFd = (int32)(x.refd34a9b90.clone_fd)
	x.MaxIdleThreads = (uint32)(x.refd34a9b90.max_idle_threads)
}

// allocStructFuseConnInfoMemory allocates memory for type C.struct_fuse_conn_info in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFuseConnInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFuseConnInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFuseConnInfoValue = unsafe.Sizeof([1]C.struct_fuse_conn_info{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConnInfo) Ref() *C.struct_fuse_conn_info {
	if x == nil {
		return nil
	}
	return x.ref2dad4d28
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConnInfo) Free() {
	if x != nil && x.allocs2dad4d28 != nil {
		x.allocs2dad4d28.(*cgoAllocMap).Free()
		x.ref2dad4d28 = nil
	}
}

// NewConnInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConnInfoRef(ref unsafe.Pointer) *ConnInfo {
	if ref == nil {
		return nil
	}
	obj := new(ConnInfo)
	obj.ref2dad4d28 = (*C.struct_fuse_conn_info)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConnInfo) PassRef() (*C.struct_fuse_conn_info, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2dad4d28 != nil {
		return x.ref2dad4d28, nil
	}
	mem2dad4d28 := allocStructFuseConnInfoMemory(1)
	ref2dad4d28 := (*C.struct_fuse_conn_info)(mem2dad4d28)
	allocs2dad4d28 := new(cgoAllocMap)
	allocs2dad4d28.Add(mem2dad4d28)

	var cproto_major_allocs *cgoAllocMap
	ref2dad4d28.proto_major, cproto_major_allocs = (C.uint)(x.ProtoMajor), cgoAllocsUnknown
	allocs2dad4d28.Borrow(cproto_major_allocs)

	var cproto_minor_allocs *cgoAllocMap
	ref2dad4d28.proto_minor, cproto_minor_allocs = (C.uint)(x.ProtoMinor), cgoAllocsUnknown
	allocs2dad4d28.Borrow(cproto_minor_allocs)

	var cmax_write_allocs *cgoAllocMap
	ref2dad4d28.max_write, cmax_write_allocs = (C.uint)(x.MaxWrite), cgoAllocsUnknown
	allocs2dad4d28.Borrow(cmax_write_allocs)

	var cmax_read_allocs *cgoAllocMap
	ref2dad4d28.max_read, cmax_read_allocs = (C.uint)(x.MaxRead), cgoAllocsUnknown
	allocs2dad4d28.Borrow(cmax_read_allocs)

	var cmax_readahead_allocs *cgoAllocMap
	ref2dad4d28.max_readahead, cmax_readahead_allocs = (C.uint)(x.MaxReadahead), cgoAllocsUnknown
	allocs2dad4d28.Borrow(cmax_readahead_allocs)

	var ccapable_allocs *cgoAllocMap
	ref2dad4d28.capable, ccapable_allocs = (C.uint)(x.Capable), cgoAllocsUnknown
	allocs2dad4d28.Borrow(ccapable_allocs)

	var cwant_allocs *cgoAllocMap
	ref2dad4d28.want, cwant_allocs = (C.uint)(x.Want), cgoAllocsUnknown
	allocs2dad4d28.Borrow(cwant_allocs)

	var cmax_background_allocs *cgoAllocMap
	ref2dad4d28.max_background, cmax_background_allocs = (C.uint)(x.MaxBackground), cgoAllocsUnknown
	allocs2dad4d28.Borrow(cmax_background_allocs)

	var ccongestion_threshold_allocs *cgoAllocMap
	ref2dad4d28.congestion_threshold, ccongestion_threshold_allocs = (C.uint)(x.CongestionThreshold), cgoAllocsUnknown
	allocs2dad4d28.Borrow(ccongestion_threshold_allocs)

	var ctime_gran_allocs *cgoAllocMap
	ref2dad4d28.time_gran, ctime_gran_allocs = (C.uint)(x.TimeGran), cgoAllocsUnknown
	allocs2dad4d28.Borrow(ctime_gran_allocs)

	var creserved_allocs *cgoAllocMap
	ref2dad4d28.reserved, creserved_allocs = *(*[22]C.uint)(unsafe.Pointer(&x.Reserved)), cgoAllocsUnknown
	allocs2dad4d28.Borrow(creserved_allocs)

	x.ref2dad4d28 = ref2dad4d28
	x.allocs2dad4d28 = allocs2dad4d28
	return ref2dad4d28, allocs2dad4d28

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConnInfo) PassValue() (C.struct_fuse_conn_info, *cgoAllocMap) {
	if x.ref2dad4d28 != nil {
		return *x.ref2dad4d28, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConnInfo) Deref() {
	if x.ref2dad4d28 == nil {
		return
	}
	x.ProtoMajor = (uint32)(x.ref2dad4d28.proto_major)
	x.ProtoMinor = (uint32)(x.ref2dad4d28.proto_minor)
	x.MaxWrite = (uint32)(x.ref2dad4d28.max_write)
	x.MaxRead = (uint32)(x.ref2dad4d28.max_read)
	x.MaxReadahead = (uint32)(x.ref2dad4d28.max_readahead)
	x.Capable = (uint32)(x.ref2dad4d28.capable)
	x.Want = (uint32)(x.ref2dad4d28.want)
	x.MaxBackground = (uint32)(x.ref2dad4d28.max_background)
	x.CongestionThreshold = (uint32)(x.ref2dad4d28.congestion_threshold)
	x.TimeGran = (uint32)(x.ref2dad4d28.time_gran)
	x.Reserved = *(*[22]uint32)(unsafe.Pointer(&x.ref2dad4d28.reserved))
}

// Ref returns a reference to C object as it is.
func (x *ConnInfoOpts) Ref() *C.struct_fuse_conn_info_opts {
	if x == nil {
		return nil
	}
	return (*C.struct_fuse_conn_info_opts)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ConnInfoOpts) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewConnInfoOptsRef converts the C object reference into a raw struct reference without wrapping.
func NewConnInfoOptsRef(ref unsafe.Pointer) *ConnInfoOpts {
	return (*ConnInfoOpts)(ref)
}

// NewConnInfoOpts allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewConnInfoOpts() *ConnInfoOpts {
	return (*ConnInfoOpts)(allocStructFuseConnInfoOptsMemory(1))
}

// allocStructFuseConnInfoOptsMemory allocates memory for type C.struct_fuse_conn_info_opts in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFuseConnInfoOptsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFuseConnInfoOptsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFuseConnInfoOptsValue = unsafe.Sizeof([1]C.struct_fuse_conn_info_opts{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ConnInfoOpts) PassRef() *C.struct_fuse_conn_info_opts {
	if x == nil {
		x = (*ConnInfoOpts)(allocStructFuseConnInfoOptsMemory(1))
	}
	return (*C.struct_fuse_conn_info_opts)(unsafe.Pointer(x))
}

// allocStructFuseCtxMemory allocates memory for type C.struct_fuse_ctx in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFuseCtxMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFuseCtxValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFuseCtxValue = unsafe.Sizeof([1]C.struct_fuse_ctx{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Ctx) Ref() *C.struct_fuse_ctx {
	if x == nil {
		return nil
	}
	return x.ref59d719ac
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Ctx) Free() {
	if x != nil && x.allocs59d719ac != nil {
		x.allocs59d719ac.(*cgoAllocMap).Free()
		x.ref59d719ac = nil
	}
}

// NewCtxRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCtxRef(ref unsafe.Pointer) *Ctx {
	if ref == nil {
		return nil
	}
	obj := new(Ctx)
	obj.ref59d719ac = (*C.struct_fuse_ctx)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Ctx) PassRef() (*C.struct_fuse_ctx, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref59d719ac != nil {
		return x.ref59d719ac, nil
	}
	mem59d719ac := allocStructFuseCtxMemory(1)
	ref59d719ac := (*C.struct_fuse_ctx)(mem59d719ac)
	allocs59d719ac := new(cgoAllocMap)
	allocs59d719ac.Add(mem59d719ac)

	var cuid_allocs *cgoAllocMap
	ref59d719ac.uid, cuid_allocs = (C.uid_t)(x.Uid), cgoAllocsUnknown
	allocs59d719ac.Borrow(cuid_allocs)

	var cgid_allocs *cgoAllocMap
	ref59d719ac.gid, cgid_allocs = (C.gid_t)(x.Gid), cgoAllocsUnknown
	allocs59d719ac.Borrow(cgid_allocs)

	var cpid_allocs *cgoAllocMap
	ref59d719ac.pid, cpid_allocs = (C.pid_t)(x.Pid), cgoAllocsUnknown
	allocs59d719ac.Borrow(cpid_allocs)

	var cumask_allocs *cgoAllocMap
	ref59d719ac.umask, cumask_allocs = (C.mode_t)(x.Umask), cgoAllocsUnknown
	allocs59d719ac.Borrow(cumask_allocs)

	x.ref59d719ac = ref59d719ac
	x.allocs59d719ac = allocs59d719ac
	return ref59d719ac, allocs59d719ac

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Ctx) PassValue() (C.struct_fuse_ctx, *cgoAllocMap) {
	if x.ref59d719ac != nil {
		return *x.ref59d719ac, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Ctx) Deref() {
	if x.ref59d719ac == nil {
		return
	}
	x.Uid = (uint32)(x.ref59d719ac.uid)
	x.Gid = (uint32)(x.ref59d719ac.gid)
	x.Pid = (int32)(x.ref59d719ac.pid)
	x.Umask = (uint32)(x.ref59d719ac.umask)
}

// allocStructFuseEntryParamMemory allocates memory for type C.struct_fuse_entry_param in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFuseEntryParamMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFuseEntryParamValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFuseEntryParamValue = unsafe.Sizeof([1]C.struct_fuse_entry_param{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EntryParam) Ref() *C.struct_fuse_entry_param {
	if x == nil {
		return nil
	}
	return x.ref66366f4f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EntryParam) Free() {
	if x != nil && x.allocs66366f4f != nil {
		x.allocs66366f4f.(*cgoAllocMap).Free()
		x.ref66366f4f = nil
	}
}

// NewEntryParamRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEntryParamRef(ref unsafe.Pointer) *EntryParam {
	if ref == nil {
		return nil
	}
	obj := new(EntryParam)
	obj.ref66366f4f = (*C.struct_fuse_entry_param)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EntryParam) PassRef() (*C.struct_fuse_entry_param, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref66366f4f != nil {
		return x.ref66366f4f, nil
	}
	mem66366f4f := allocStructFuseEntryParamMemory(1)
	ref66366f4f := (*C.struct_fuse_entry_param)(mem66366f4f)
	allocs66366f4f := new(cgoAllocMap)
	allocs66366f4f.Add(mem66366f4f)

	var cino_allocs *cgoAllocMap
	ref66366f4f.ino, cino_allocs = (C.fuse_ino_t)(x.Ino), cgoAllocsUnknown
	allocs66366f4f.Borrow(cino_allocs)

	var cgeneration_allocs *cgoAllocMap
	ref66366f4f.generation, cgeneration_allocs = (C.uint64_t)(x.Generation), cgoAllocsUnknown
	allocs66366f4f.Borrow(cgeneration_allocs)

	var cattr_timeout_allocs *cgoAllocMap
	ref66366f4f.attr_timeout, cattr_timeout_allocs = (C.double)(x.AttrTimeout), cgoAllocsUnknown
	allocs66366f4f.Borrow(cattr_timeout_allocs)

	var centry_timeout_allocs *cgoAllocMap
	ref66366f4f.entry_timeout, centry_timeout_allocs = (C.double)(x.EntryTimeout), cgoAllocsUnknown
	allocs66366f4f.Borrow(centry_timeout_allocs)

	x.ref66366f4f = ref66366f4f
	x.allocs66366f4f = allocs66366f4f
	return ref66366f4f, allocs66366f4f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EntryParam) PassValue() (C.struct_fuse_entry_param, *cgoAllocMap) {
	if x.ref66366f4f != nil {
		return *x.ref66366f4f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EntryParam) Deref() {
	if x.ref66366f4f == nil {
		return
	}
	x.Ino = (Ino)(x.ref66366f4f.ino)
	x.Generation = (uint32)(x.ref66366f4f.generation)
	x.AttrTimeout = (float64)(x.ref66366f4f.attr_timeout)
	x.EntryTimeout = (float64)(x.ref66366f4f.entry_timeout)
}

// allocStructFuseFileInfoMemory allocates memory for type C.struct_fuse_file_info in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFuseFileInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFuseFileInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFuseFileInfoValue = unsafe.Sizeof([1]C.struct_fuse_file_info{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FileInfo) Ref() *C.struct_fuse_file_info {
	if x == nil {
		return nil
	}
	return x.ref5c0de00a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FileInfo) Free() {
	if x != nil && x.allocs5c0de00a != nil {
		x.allocs5c0de00a.(*cgoAllocMap).Free()
		x.ref5c0de00a = nil
	}
}

// NewFileInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFileInfoRef(ref unsafe.Pointer) *FileInfo {
	if ref == nil {
		return nil
	}
	obj := new(FileInfo)
	obj.ref5c0de00a = (*C.struct_fuse_file_info)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FileInfo) PassRef() (*C.struct_fuse_file_info, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5c0de00a != nil {
		return x.ref5c0de00a, nil
	}
	mem5c0de00a := allocStructFuseFileInfoMemory(1)
	ref5c0de00a := (*C.struct_fuse_file_info)(mem5c0de00a)
	allocs5c0de00a := new(cgoAllocMap)
	allocs5c0de00a.Add(mem5c0de00a)

	var cflags_allocs *cgoAllocMap
	ref5c0de00a.flags, cflags_allocs = (C.int)(x.Flags), cgoAllocsUnknown
	allocs5c0de00a.Borrow(cflags_allocs)

	var cwritepage_allocs *cgoAllocMap
	ref5c0de00a.writepage, cwritepage_allocs = (C.uint)(x.Writepage), cgoAllocsUnknown
	allocs5c0de00a.Borrow(cwritepage_allocs)

	var cdirect_io_allocs *cgoAllocMap
	ref5c0de00a.direct_io, cdirect_io_allocs = (C.uint)(x.DirectIo), cgoAllocsUnknown
	allocs5c0de00a.Borrow(cdirect_io_allocs)

	var ckeep_cache_allocs *cgoAllocMap
	ref5c0de00a.keep_cache, ckeep_cache_allocs = (C.uint)(x.KeepCache), cgoAllocsUnknown
	allocs5c0de00a.Borrow(ckeep_cache_allocs)

	var cflush_allocs *cgoAllocMap
	ref5c0de00a.flush, cflush_allocs = (C.uint)(x.Flush), cgoAllocsUnknown
	allocs5c0de00a.Borrow(cflush_allocs)

	var cnonseekable_allocs *cgoAllocMap
	ref5c0de00a.nonseekable, cnonseekable_allocs = (C.uint)(x.Nonseekable), cgoAllocsUnknown
	allocs5c0de00a.Borrow(cnonseekable_allocs)

	var cflock_release_allocs *cgoAllocMap
	ref5c0de00a.flock_release, cflock_release_allocs = (C.uint)(x.FlockRelease), cgoAllocsUnknown
	allocs5c0de00a.Borrow(cflock_release_allocs)

	var ccache_readdir_allocs *cgoAllocMap
	ref5c0de00a.cache_readdir, ccache_readdir_allocs = (C.uint)(x.CacheReaddir), cgoAllocsUnknown
	allocs5c0de00a.Borrow(ccache_readdir_allocs)

	var cpadding_allocs *cgoAllocMap
	ref5c0de00a.padding, cpadding_allocs = (C.uint)(x.Padding), cgoAllocsUnknown
	allocs5c0de00a.Borrow(cpadding_allocs)

	var cpadding2_allocs *cgoAllocMap
	ref5c0de00a.padding2, cpadding2_allocs = (C.uint)(x.Padding2), cgoAllocsUnknown
	allocs5c0de00a.Borrow(cpadding2_allocs)

	var cfh_allocs *cgoAllocMap
	ref5c0de00a.fh, cfh_allocs = (C.uint64_t)(x.Fh), cgoAllocsUnknown
	allocs5c0de00a.Borrow(cfh_allocs)

	var clock_owner_allocs *cgoAllocMap
	ref5c0de00a.lock_owner, clock_owner_allocs = (C.uint64_t)(x.LockOwner), cgoAllocsUnknown
	allocs5c0de00a.Borrow(clock_owner_allocs)

	var cpoll_events_allocs *cgoAllocMap
	ref5c0de00a.poll_events, cpoll_events_allocs = (C.uint32_t)(x.PollEvents), cgoAllocsUnknown
	allocs5c0de00a.Borrow(cpoll_events_allocs)

	x.ref5c0de00a = ref5c0de00a
	x.allocs5c0de00a = allocs5c0de00a
	return ref5c0de00a, allocs5c0de00a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FileInfo) PassValue() (C.struct_fuse_file_info, *cgoAllocMap) {
	if x.ref5c0de00a != nil {
		return *x.ref5c0de00a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FileInfo) Deref() {
	if x.ref5c0de00a == nil {
		return
	}
	x.Flags = (int32)(x.ref5c0de00a.flags)
	x.Writepage = (uint32)(x.ref5c0de00a.writepage)
	x.DirectIo = (uint32)(x.ref5c0de00a.direct_io)
	x.KeepCache = (uint32)(x.ref5c0de00a.keep_cache)
	x.Flush = (uint32)(x.ref5c0de00a.flush)
	x.Nonseekable = (uint32)(x.ref5c0de00a.nonseekable)
	x.FlockRelease = (uint32)(x.ref5c0de00a.flock_release)
	x.CacheReaddir = (uint32)(x.ref5c0de00a.cache_readdir)
	x.Padding = (uint32)(x.ref5c0de00a.padding)
	x.Padding2 = (uint32)(x.ref5c0de00a.padding2)
	x.Fh = (uint32)(x.ref5c0de00a.fh)
	x.LockOwner = (uint32)(x.ref5c0de00a.lock_owner)
	x.PollEvents = (uint32)(x.ref5c0de00a.poll_events)
}

// allocStructFuseForgetDataMemory allocates memory for type C.struct_fuse_forget_data in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFuseForgetDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFuseForgetDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFuseForgetDataValue = unsafe.Sizeof([1]C.struct_fuse_forget_data{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ForgetData) Ref() *C.struct_fuse_forget_data {
	if x == nil {
		return nil
	}
	return x.refce6ed80b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ForgetData) Free() {
	if x != nil && x.allocsce6ed80b != nil {
		x.allocsce6ed80b.(*cgoAllocMap).Free()
		x.refce6ed80b = nil
	}
}

// NewForgetDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewForgetDataRef(ref unsafe.Pointer) *ForgetData {
	if ref == nil {
		return nil
	}
	obj := new(ForgetData)
	obj.refce6ed80b = (*C.struct_fuse_forget_data)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ForgetData) PassRef() (*C.struct_fuse_forget_data, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refce6ed80b != nil {
		return x.refce6ed80b, nil
	}
	memce6ed80b := allocStructFuseForgetDataMemory(1)
	refce6ed80b := (*C.struct_fuse_forget_data)(memce6ed80b)
	allocsce6ed80b := new(cgoAllocMap)
	allocsce6ed80b.Add(memce6ed80b)

	var cino_allocs *cgoAllocMap
	refce6ed80b.ino, cino_allocs = (C.fuse_ino_t)(x.Ino), cgoAllocsUnknown
	allocsce6ed80b.Borrow(cino_allocs)

	var cnlookup_allocs *cgoAllocMap
	refce6ed80b.nlookup, cnlookup_allocs = (C.uint64_t)(x.Nlookup), cgoAllocsUnknown
	allocsce6ed80b.Borrow(cnlookup_allocs)

	x.refce6ed80b = refce6ed80b
	x.allocsce6ed80b = allocsce6ed80b
	return refce6ed80b, allocsce6ed80b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ForgetData) PassValue() (C.struct_fuse_forget_data, *cgoAllocMap) {
	if x.refce6ed80b != nil {
		return *x.refce6ed80b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ForgetData) Deref() {
	if x.refce6ed80b == nil {
		return
	}
	x.Ino = (Ino)(x.refce6ed80b.ino)
	x.Nlookup = (uint32)(x.refce6ed80b.nlookup)
}

// allocStructFuseLoopConfigMemory allocates memory for type C.struct_fuse_loop_config in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFuseLoopConfigMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFuseLoopConfigValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFuseLoopConfigValue = unsafe.Sizeof([1]C.struct_fuse_loop_config{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *LoopConfig) Ref() *C.struct_fuse_loop_config {
	if x == nil {
		return nil
	}
	return x.refc82c52ea
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *LoopConfig) Free() {
	if x != nil && x.allocsc82c52ea != nil {
		x.allocsc82c52ea.(*cgoAllocMap).Free()
		x.refc82c52ea = nil
	}
}

// NewLoopConfigRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewLoopConfigRef(ref unsafe.Pointer) *LoopConfig {
	if ref == nil {
		return nil
	}
	obj := new(LoopConfig)
	obj.refc82c52ea = (*C.struct_fuse_loop_config)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *LoopConfig) PassRef() (*C.struct_fuse_loop_config, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc82c52ea != nil {
		return x.refc82c52ea, nil
	}
	memc82c52ea := allocStructFuseLoopConfigMemory(1)
	refc82c52ea := (*C.struct_fuse_loop_config)(memc82c52ea)
	allocsc82c52ea := new(cgoAllocMap)
	allocsc82c52ea.Add(memc82c52ea)

	var cclone_fd_allocs *cgoAllocMap
	refc82c52ea.clone_fd, cclone_fd_allocs = (C.int)(x.CloneFd), cgoAllocsUnknown
	allocsc82c52ea.Borrow(cclone_fd_allocs)

	var cmax_idle_threads_allocs *cgoAllocMap
	refc82c52ea.max_idle_threads, cmax_idle_threads_allocs = (C.uint)(x.MaxIdleThreads), cgoAllocsUnknown
	allocsc82c52ea.Borrow(cmax_idle_threads_allocs)

	x.refc82c52ea = refc82c52ea
	x.allocsc82c52ea = allocsc82c52ea
	return refc82c52ea, allocsc82c52ea

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x LoopConfig) PassValue() (C.struct_fuse_loop_config, *cgoAllocMap) {
	if x.refc82c52ea != nil {
		return *x.refc82c52ea, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *LoopConfig) Deref() {
	if x.refc82c52ea == nil {
		return
	}
	x.CloneFd = (int32)(x.refc82c52ea.clone_fd)
	x.MaxIdleThreads = (uint32)(x.refc82c52ea.max_idle_threads)
}

// allocStructFuseOptMemory allocates memory for type C.struct_fuse_opt in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFuseOptMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFuseOptValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFuseOptValue = unsafe.Sizeof([1]C.struct_fuse_opt{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Opt) Ref() *C.struct_fuse_opt {
	if x == nil {
		return nil
	}
	return x.ref3d1769e7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Opt) Free() {
	if x != nil && x.allocs3d1769e7 != nil {
		x.allocs3d1769e7.(*cgoAllocMap).Free()
		x.ref3d1769e7 = nil
	}
}

// NewOptRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOptRef(ref unsafe.Pointer) *Opt {
	if ref == nil {
		return nil
	}
	obj := new(Opt)
	obj.ref3d1769e7 = (*C.struct_fuse_opt)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Opt) PassRef() (*C.struct_fuse_opt, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3d1769e7 != nil {
		return x.ref3d1769e7, nil
	}
	mem3d1769e7 := allocStructFuseOptMemory(1)
	ref3d1769e7 := (*C.struct_fuse_opt)(mem3d1769e7)
	allocs3d1769e7 := new(cgoAllocMap)
	allocs3d1769e7.Add(mem3d1769e7)

	var ctempl_allocs *cgoAllocMap
	ref3d1769e7.templ, ctempl_allocs = unpackPCharString(x.Templ)
	allocs3d1769e7.Borrow(ctempl_allocs)

	var coffset_allocs *cgoAllocMap
	ref3d1769e7.offset, coffset_allocs = (C.ulong)(x.Offset), cgoAllocsUnknown
	allocs3d1769e7.Borrow(coffset_allocs)

	var cvalue_allocs *cgoAllocMap
	ref3d1769e7.value, cvalue_allocs = (C.int)(x.Value), cgoAllocsUnknown
	allocs3d1769e7.Borrow(cvalue_allocs)

	x.ref3d1769e7 = ref3d1769e7
	x.allocs3d1769e7 = allocs3d1769e7
	return ref3d1769e7, allocs3d1769e7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Opt) PassValue() (C.struct_fuse_opt, *cgoAllocMap) {
	if x.ref3d1769e7 != nil {
		return *x.ref3d1769e7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Opt) Deref() {
	if x.ref3d1769e7 == nil {
		return
	}
	x.Templ = packPCharString(x.ref3d1769e7.templ)
	x.Offset = (uint32)(x.ref3d1769e7.offset)
	x.Value = (int32)(x.ref3d1769e7.value)
}

// Ref returns a reference to C object as it is.
func (x *Pollhandle) Ref() *C.struct_fuse_pollhandle {
	if x == nil {
		return nil
	}
	return (*C.struct_fuse_pollhandle)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Pollhandle) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPollhandleRef converts the C object reference into a raw struct reference without wrapping.
func NewPollhandleRef(ref unsafe.Pointer) *Pollhandle {
	return (*Pollhandle)(ref)
}

// NewPollhandle allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPollhandle() *Pollhandle {
	return (*Pollhandle)(allocStructFusePollhandleMemory(1))
}

// allocStructFusePollhandleMemory allocates memory for type C.struct_fuse_pollhandle in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFusePollhandleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFusePollhandleValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFusePollhandleValue = unsafe.Sizeof([1]C.struct_fuse_pollhandle{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Pollhandle) PassRef() *C.struct_fuse_pollhandle {
	if x == nil {
		x = (*Pollhandle)(allocStructFusePollhandleMemory(1))
	}
	return (*C.struct_fuse_pollhandle)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Session) Ref() *C.struct_fuse_session {
	if x == nil {
		return nil
	}
	return (*C.struct_fuse_session)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Session) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewSessionRef converts the C object reference into a raw struct reference without wrapping.
func NewSessionRef(ref unsafe.Pointer) *Session {
	return (*Session)(ref)
}

// NewSession allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewSession() *Session {
	return (*Session)(allocStructFuseSessionMemory(1))
}

// allocStructFuseSessionMemory allocates memory for type C.struct_fuse_session in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFuseSessionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFuseSessionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFuseSessionValue = unsafe.Sizeof([1]C.struct_fuse_session{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Session) PassRef() *C.struct_fuse_session {
	if x == nil {
		x = (*Session)(allocStructFuseSessionMemory(1))
	}
	return (*C.struct_fuse_session)(unsafe.Pointer(x))
}

// unpackArgSArgs transforms a sliced Go data structure into plain C format.
func unpackArgSArgs(x []Args) (unpacked *C.struct_fuse_args, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocStructFuseArgsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_fuse_args)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_fuse_args)(h.Data)
	return
}

// unpackArgSInfo transforms a sliced Go data structure into plain C format.
func unpackArgSInfo(x []Info) (unpacked *C.struct_cuse_info, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocStructCuseInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_cuse_info)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_cuse_info)(h.Data)
	return
}

// packSInfo reads sliced Go data structure out from plain C format.
func packSInfo(v []Info, ptr0 *C.struct_cuse_info) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructCuseInfoValue]C.struct_cuse_info)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSLowlevelOps transforms a sliced Go data structure into plain C format.
func unpackArgSLowlevelOps(x []LowlevelOps) (unpacked *C.struct_cuse_lowlevel_ops, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocStructCuseLowlevelOpsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_cuse_lowlevel_ops)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_cuse_lowlevel_ops)(h.Data)
	return
}

// packSLowlevelOps reads sliced Go data structure out from plain C format.
func packSLowlevelOps(v []LowlevelOps, ptr0 *C.struct_cuse_lowlevel_ops) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructCuseLowlevelOpsValue]C.struct_cuse_lowlevel_ops)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewLowlevelOpsRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSByte transforms a sliced Go data structure into plain C format.
func unpackArgSSByte(x [][]byte) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.char)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// copyPIntBytes copies the data from Go slice as *C.int.
func copyPIntBytes(slice *sliceHeader) (*C.int, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfIntValue) * slice.Len,
		Cap:  int(sizeOfIntValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.int)(mem0), allocs
}

// allocIntMemory allocates memory for type C.int in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIntMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIntValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfIntValue = unsafe.Sizeof([1]C.int{})

// copyPStructFuseSessionBytes copies the data from Go slice as *C.struct_fuse_session.
func copyPStructFuseSessionBytes(slice *sliceHeader) (*C.struct_fuse_session, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfStructFuseSessionValue) * slice.Len,
		Cap:  int(sizeOfStructFuseSessionValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.struct_fuse_session)(mem0), allocs
}

// unpackArgSEntryParam transforms a sliced Go data structure into plain C format.
func unpackArgSEntryParam(x []EntryParam) (unpacked *C.struct_fuse_entry_param, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocStructFuseEntryParamMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_fuse_entry_param)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_fuse_entry_param)(h.Data)
	return
}

// packSEntryParam reads sliced Go data structure out from plain C format.
func packSEntryParam(v []EntryParam, ptr0 *C.struct_fuse_entry_param) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructFuseEntryParamValue]C.struct_fuse_entry_param)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewEntryParamRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSFileInfo transforms a sliced Go data structure into plain C format.
func unpackArgSFileInfo(x []FileInfo) (unpacked *C.struct_fuse_file_info, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocStructFuseFileInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_fuse_file_info)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_fuse_file_info)(h.Data)
	return
}

// packSFileInfo reads sliced Go data structure out from plain C format.
func packSFileInfo(v []FileInfo, ptr0 *C.struct_fuse_file_info) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructFuseFileInfoValue]C.struct_fuse_file_info)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFileInfoRef(unsafe.Pointer(&ptr1))
	}
}

// allocStructStatMemory allocates memory for type C.struct_stat in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructStatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructStatValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructStatValue = unsafe.Sizeof([1]C.struct_stat{})

// unpackArgSStat transforms a sliced Go data structure into plain C format.
func unpackArgSStat(x []Stat) (unpacked *C.struct_stat, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocStructStatMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_stat)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_stat)(h.Data)
	return
}

// packSStat reads sliced Go data structure out from plain C format.
func packSStat(v []Stat, ptr0 *C.struct_stat) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructStatValue]C.struct_stat)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewStatRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSBufvec transforms a sliced Go data structure into plain C format.
func unpackArgSBufvec(x []Bufvec) (unpacked *C.struct_fuse_bufvec, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocStructFuseBufvecMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_fuse_bufvec)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_fuse_bufvec)(h.Data)
	return
}

// packSBufvec reads sliced Go data structure out from plain C format.
func packSBufvec(v []Bufvec, ptr0 *C.struct_fuse_bufvec) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructFuseBufvecValue]C.struct_fuse_bufvec)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufvecRef(unsafe.Pointer(&ptr1))
	}
}

// allocStructIovecMemory allocates memory for type C.struct_iovec in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructIovecMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructIovecValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructIovecValue = unsafe.Sizeof([1]C.struct_iovec{})

// unpackArgSIovec transforms a sliced Go data structure into plain C format.
func unpackArgSIovec(x []Iovec) (unpacked *C.struct_iovec, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocStructIovecMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_iovec)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_iovec)(h.Data)
	return
}

// packSIovec reads sliced Go data structure out from plain C format.
func packSIovec(v []Iovec, ptr0 *C.struct_iovec) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructIovecValue]C.struct_iovec)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewIovecRef(unsafe.Pointer(&ptr1))
	}
}

// allocStructStatvfsMemory allocates memory for type C.struct_statvfs in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructStatvfsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructStatvfsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructStatvfsValue = unsafe.Sizeof([1]C.struct_statvfs{})

// unpackArgSStatvfs transforms a sliced Go data structure into plain C format.
func unpackArgSStatvfs(x []Statvfs) (unpacked *C.struct_statvfs, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocStructStatvfsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_statvfs)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_statvfs)(h.Data)
	return
}

// packSStatvfs reads sliced Go data structure out from plain C format.
func packSStatvfs(v []Statvfs, ptr0 *C.struct_statvfs) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructStatvfsValue]C.struct_statvfs)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewStatvfsRef(unsafe.Pointer(&ptr1))
	}
}

// allocStructFlockMemory allocates memory for type C.struct_flock in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFlockMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFlockValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFlockValue = unsafe.Sizeof([1]C.struct_flock{})

// unpackArgSFlock transforms a sliced Go data structure into plain C format.
func unpackArgSFlock(x []Flock) (unpacked *C.struct_flock, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocStructFlockMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_flock)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_flock)(h.Data)
	return
}

// packSFlock reads sliced Go data structure out from plain C format.
func packSFlock(v []Flock, ptr0 *C.struct_flock) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructFlockValue]C.struct_flock)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFlockRef(unsafe.Pointer(&ptr1))
	}
}

// copyPStructFusePollhandleBytes copies the data from Go slice as *C.struct_fuse_pollhandle.
func copyPStructFusePollhandleBytes(slice *sliceHeader) (*C.struct_fuse_pollhandle, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfStructFusePollhandleValue) * slice.Len,
		Cap:  int(sizeOfStructFusePollhandleValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.struct_fuse_pollhandle)(mem0), allocs
}

// copyPGidBytes copies the data from Go slice as *C.gid_t.
func copyPGidBytes(slice *sliceHeader) (*C.gid_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfGidValue) * slice.Len,
		Cap:  int(sizeOfGidValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.gid_t)(mem0), allocs
}

// allocGidMemory allocates memory for type C.gid_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGidMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGidValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGidValue = unsafe.Sizeof([1]C.gid_t{})

// unpackArgSCmdlineOpts transforms a sliced Go data structure into plain C format.
func unpackArgSCmdlineOpts(x []CmdlineOpts) (unpacked *C.struct_fuse_cmdline_opts, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocStructFuseCmdlineOptsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_fuse_cmdline_opts)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_fuse_cmdline_opts)(h.Data)
	return
}

// packSCmdlineOpts reads sliced Go data structure out from plain C format.
func packSCmdlineOpts(v []CmdlineOpts, ptr0 *C.struct_fuse_cmdline_opts) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructFuseCmdlineOptsValue]C.struct_fuse_cmdline_opts)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCmdlineOptsRef(unsafe.Pointer(&ptr1))
	}
}

// allocStructFuseLowlevelOpsMemory allocates memory for type C.struct_fuse_lowlevel_ops in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFuseLowlevelOpsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFuseLowlevelOpsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFuseLowlevelOpsValue = unsafe.Sizeof([1]C.struct_fuse_lowlevel_ops{})

// unpackArgSBuf transforms a sliced Go data structure into plain C format.
func unpackArgSBuf(x []Buf) (unpacked *C.struct_fuse_buf, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocStructFuseBufMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_fuse_buf)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_fuse_buf)(h.Data)
	return
}

// packSBuf reads sliced Go data structure out from plain C format.
func packSBuf(v []Buf, ptr0 *C.struct_fuse_buf) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructFuseBufValue]C.struct_fuse_buf)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufRef(unsafe.Pointer(&ptr1))
	}
}

// copyPStructFuseConnInfoOptsBytes copies the data from Go slice as *C.struct_fuse_conn_info_opts.
func copyPStructFuseConnInfoOptsBytes(slice *sliceHeader) (*C.struct_fuse_conn_info_opts, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfStructFuseConnInfoOptsValue) * slice.Len,
		Cap:  int(sizeOfStructFuseConnInfoOptsValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.struct_fuse_conn_info_opts)(mem0), allocs
}

// unpackArgSConnInfo transforms a sliced Go data structure into plain C format.
func unpackArgSConnInfo(x []ConnInfo) (unpacked *C.struct_fuse_conn_info, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocStructFuseConnInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_fuse_conn_info)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_fuse_conn_info)(h.Data)
	return
}

// packSConnInfo reads sliced Go data structure out from plain C format.
func packSConnInfo(v []ConnInfo, ptr0 *C.struct_fuse_conn_info) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructFuseConnInfoValue]C.struct_fuse_conn_info)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewConnInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSOpt transforms a sliced Go data structure into plain C format.
func unpackArgSOpt(x []Opt) (unpacked *C.struct_fuse_opt, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocStructFuseOptMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_fuse_opt)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_fuse_opt)(h.Data)
	return
}

// packSOpt reads sliced Go data structure out from plain C format.
func packSOpt(v []Opt, ptr0 *C.struct_fuse_opt) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructFuseOptValue]C.struct_fuse_opt)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewOptRef(unsafe.Pointer(&ptr1))
	}
}
